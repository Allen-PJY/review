# 笔试

### 1. 按字典中的value值进行排序

```python
d = {'a': 22, 'b': 44, 'c': 11, 'd': 33}
sorted(d.items(), key=lambda x: x[1])
```

### 2. Redis由于存储的指纹过多怎么办

- 设置生存时间

- 定时清理

- 持久化

- 主从

### 3. Phontomjs相关

- 主程序退出后，selenium 不保证 phantomJS 也成功退出，最好手动关闭phantomJS 进程。（有可能会导致多个 phantomJS 进程运行，占用内存）
- WebDriverWait 虽然可能会减少延时，但是目前存在 bug（各种报错），这种情况可以采用 sleep。
- phantomJS 爬数据比较慢，可以选择多线程。如果运行的时候发现有的可以运行，有的不能，可以尝试将 phantomJS 改成 Chrome。

### 4. 什么是函数

- 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

- 函数能提高应用的模块性，和代码的重复利用率。

- Python提供了许多内建函数，但也可以自己创建函数，这被叫做用户自定义函数

### 5. scrapy-redis 去重原理

- 可见scrapy_redis是利用set数据结构来去重的，去重的对象是request的fingerprint
- （其实就是用hashlib .sha1()对request 对象的某些字段信息进行压缩）。
- request对象加密压缩后的一个字符串（40个字符，0~f）

### 6. map函数和reduce函数

- 从参数方面来讲：
	- map()包含两个参数，第一个是参数是一个函数，第二个是序列（列表或元组）。
	- 其中，函数（即 map 的第一个参数位置的函数）可以接收一个或多个参数。

	- reduce() 第一个参数是函数，第二个是 序列（列表或元组）。
	- 但是，其函数必须接收两个参数。

- 从对传进去的数值作用来讲：
	- map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次
	- reduce()是将传人的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算）。

### 7. Python的引用类型有哪些

- 对象本身可以修改，比如列表，字典等

### 8. `self` 和 `cls` 区别

- 一般用到 `staticmethod`, `classmethod` 或者后期绑定就用 `cls`
- 否则就用 `self` , 属于 `*args` 的范畴的

### 9. 怎么设置深度爬取

- 通过在`settings.py`中设置`DEPTH_LIMIT`的值可以限制爬取深度
- 这个深度是与`start_urls`中定义`url`的相对值。也就是相对`url`的深度。
- 若定义`url`为http://www.domz.com/game/, `DEPTH_LIMIT`=1那么限制爬取的只能是此`url`下一级的网页。
- 深度大于设置值的将被忽视。

### 10. 怎么存储图片和视频

- 一般存储的是 URI
- 文件保存在云服务器

### 11. a=1, b=2, 不用中间变量交换a和b的值（两种方法）
```python
a, b = b, a
```

```python
a = a + b
b = a - b
a = a - b
```

### 12. 代理ip里的“透明” “匿名” “高匿” 分别指什么

- `透明代理`
	- 传送的是真实的 IP
	- 是客户端根本不需要知道有代理服务器的存在
	- 你要想隐藏的话，不要用这个

- `普通匿名代理`
	- 隐藏客户机的真实IP
	- 会改变我们的请求信息
	- 服务器端知道我们使用了代理
	- 当然某些能够侦测ip的网页仍然可以查到你的ip

- `高匿名代理`
	- 隐藏客户机的真实IP
	- 不改变我们的请求信息
	- 服务器端不知道我们使用了代理

### 13. 求今天是本年、本月、本周的第几天
```python
# -*- coding:utf-8 -*-
import datetime

date = datetime.datetime.now()
date_list = date.strftime('%Y-%m-%d').split('-')

year_index = int(date.strftime('%j'))
month_index = date_list[2]
week_index = date.weekday() + 1

print("是本年第{}天".format(year_index))
print('是本月第{}天'.format(month_index))
print('是本周第{}天'.format(week_index))
```

### 14. `MD5`

- `MD5` 功能：
	- 输入任意长度的信息，经过处理，输出为 `128` 位的信息（数字指纹）
	- 不同的输入得到的不同的结果（唯一性）；
	- 输出结果不可反推（不可逆）；

- `MD5` 用途：
	- 防止被篡改
	- 防止直接看到明文
	- 防止抵赖（数字签名）

- `MD5` 算法过程：
	- MD5以`512位分组`来处理输入的信息
	- 每一分组又被划分为`16个32位子分组`
	- 经过了一系列的处理后，算法的输出由`四个32位分组`组成
	- 将这`四个32位分组`级联后将生成一个`128位散列值`

### 15. 哈希表

- 哈希表就是一种以 `键-值(key-indexed)` 存储数据的结构，我们只要输入待查找的键 `key`，即可查找到其对应的值 `value`。

> 哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：
将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。
这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

- 哈希查找两步走:

	- 1) 使用哈希函数将被查找的键转换为数组的索引
		- 在理想的情况下，不同的键会被转换为不同的索引值
		- 但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况
		- 所以哈希查找的第二个步骤就是处理冲突

	- 2) 处理哈希碰撞冲突。
		- 哈希表是一个在时间和空间上做出权衡的经典例子
		- 如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为 O(1)
		- 如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存
		- 哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡
		- 只需要调整哈希函数算法即可在时间和空间上做出取舍

### 16. python的魔法方法

> 魔法方法就是可以给你的类增加魔力的特殊方法，
如果你的对象实现（重载）了这些方法中的某一个，
那么这个方法就会在特殊的情况下被Python所调用，你可以定义自己想要的行为，而这一切都是自动发生的。
它们经常是两个下划线包围来命名的（比如 `__init__` ，`__lt__`），Python的魔法方法是非常强大的，所以了解其使用方法也变得尤为重要！

- `__init__ ` 构造器，当一个实例被创建的时候初始化的方法。但是它并不是实例化调用的第一个方法。

- `__new__` 才是实例化对象调用的第一个方法，它只取下 `cls` 参数，并把其他参数传给 `__init__` 。
	- `__new__` 很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。

- `__call__` 允许一个类的实例像函数一样被调用

- `__getitem__` 定义获取容器中指定元素的行为，相当于 self[key]

- `__getattr__` 定义当用户试图访问一个不存在属性的时候的行为

- `__setattr__` 定义当一个属性被设置的时候的行为

- `__getattribute__` 定义当一个属性被访问的时候的行为


### 17. 字符、字符集、字符编码

- 字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。

- 字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同

- 字符编码就是以二进制的数字来对应字符集的字符。

- 常见字符集（编码字符集）有：`ASCII` 字符集、`ISO 8859` 字符集、`GB2312` 字符集、`BIG5` 字符集、`GB18030` 字符集、`Unicode` 字符集等。

	- `Unicode`：也叫统一字符集，它包含了几乎世界上所有的已经发现且需要使用的字符（如中文、日文、英文、德文等）。
	- `ASCII`：ASCII既是编码字符集，又是字符编码。
		- 早期的计算机系统只能处理英文，所以ASCII也就成为了计算机的缺省字符集，包含了英文所需要的所有字符。
	- `GB2312`：中文字符集，包含 `ASCII` 字符集。`ASCII` 部分用单字节表示，剩余部分用双字节表示。
	- `GBK`：`GB2312` 的扩展，但完整包含了 `GB2312` 的所有内容。
	- `GB18030`：GBK 字符集的超集，常叫*大汉字字符集*，也叫 `CJK`（Chinese，Japanese，Korea）字符集，包含了中、日、韩三国语言

- *注意：*
	- `Unicode` 字符集有多种编码方式，如 `UTF-8`、`UTF-16` 等
	- `ASCII` 只有一种
	- 大多数 `MBCS`（包括 `GB2312`）也只有一种。

### 18. 去除列表里面最大值

```python
import numpy

ret = [1, 3, 5, 7]
ret.remove(numpy.max(ret))
```

### 19. 如何编写有序字典

```python
from collections import OrderedDict

order_dict = OrderedDict()  # 创建有序字典
order_dict['name'] = 'xiaoming'  # 加入键值对
print(order_dict)  # 显示有序字典

order_dict.clear()  # 清空有序字典
print(order_dict)  # 显示有序字典
print('\n'.join(dir(OrderedDict)))  # 列出所有的成员函数
```

### 20. `with`语句

- `with`语句适用于对资源进行访问的场合

- 确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源

- 比如文件使用后自动关闭、线程中锁的自动获取和释放等。

### 21. `requests` 返回的 `context` 和 `text` 的区别

- `resp.text` 返回的是 `Unicode` 型的数据。
- `resp.content` 返回的是 `bytes` 型(二进制)的数据

### 22. `MySQLdb.connect`中 `cursorclass = MySQLdb.cursors.DictCursor` 参数用途

- `cursorclass` 是创建 `cursor` 对象的参数，执行查询后每条记录的结果以列表形式表示。

- `cursors` 参数为 `MySQLdb.cursors.DictCursor` 表示按字典形式返回查询记录。

### 23. 用conn.execute()执行sql返回什么

- 返回执行 SQL 语句后受影响的行数

### 24. cursor.execute查询结果后，有哪些方法可以获得结果

- `fetchone()`
- `fetchall()`
- `fetchmany()` 可指定返回个数 `fetchmany(3)`

### 25. 有一个已经排好序的数组 l = [0, 10, 20, 30, 40, 50]. 现输入一个数， 要求按原来的规律将它插入数组中

```python
num_list = [0, 10, 20, 30, 40, 50]
n = int(input('Input a number:'))

for i in range(len(num_list)):
    if n < num_list[i]:
        num_list.insert(i, n)
        break

print('The new sorted list is:{}'.format(num_list))
```

### 27. 解释 `列表推导式` 和 `生成器` 区别

```python
nums = [lambda x: i*x for i in range(4)]
print([f(2) for f in nums])

# result
[6, 6, 6, 6]
```

- 列表推导式保存了4个函数对象
- 每次生成局部变量`i`后，由于没有保存，后续的`i`覆盖了之前的`i`
- 最终`i` 保存的值是3

```python
nums = (lambda x: i*x for i in range(4))
print([f(2) for f in nums])

# result
[0, 2, 4, 6]
```

- 生成器拥有"惰性计算"的特点
- 从`nums`中取值时才会计算`i`的值，并立即把最终的计算结果赋值给f，再计算`f(2)`，追加到列表中
- 然后调用生成器的 `__next__()` 方法获取下一个函数对象（此时已经丢弃上一个函数对象）
- 每次处理一个对象，而不是一口气处理和构造整个数据结构，这样做的潜在优点是可以节省大量的内存

> 列表、列表推导式、生成器占用内存对比

```python
In [1]: import sys

In [2]: a = range(1000000)

In [3]: b = list(range(1000000))

In [4]: c = [x for x in range(1000000)]

In [5]: f = sys.getsizeof

In [6]: f(a)
Out[6]: 48

In [7]: f(b)
Out[7]: 9000112

In [8]: f(c)
Out[8]: 8697464
```

### 29. 队列和栈

- 栈
	- 栈是一种特殊的线性表。
	- 其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。
	- `后进先出` (`Last In First Out`), 简称为 `LIFO表`

- 栈的基本运算(6种)：
	- 构造空栈:   `InitStack(S)`
	- 判栈空:     `StackEmpty(S)`
	- 判栈满:     `StackFull(S)`
	- 进栈:       `Push(S,x)`
	- 退栈:       `Pop(S)`
	- 取栈顶元素: `StackTop(S)` 不同于弹出，栈顶元素保留。

- 队列
	- 队列(Queue)也是一种运算受限的线性表
	- 它的运算限制与栈不同，是两头都有限制
	- **插入** 只能在表的一端进行(`只进不出`)，称为**队头**(Front)
	- **删除** 只能在表的另一端进行(`只出不进`)，称为**队尾**(rear)
	- `先进先出` (`FirstInFirstOut`), 所以队列又称作 `FIFO表` 

- 队列的基本运算(6种)：
	- 置空队：    `InitQueue(Q)`
	- 判队空:     `QueueEmpty(Q)`
	- 判队满:     `QueueFull(Q)`
	- 入队:       `EnQueue(Q,x)`
	- 出队:       `DeQueue(Q)`
	- 取队头元素: `QueueFront(Q)`, 不同于出队，队头元素保留。

### 30. 用两个队列如何实现一个栈，用两个栈如何实现一个队列

#### 两个栈实现一个队列
> 栈的特性是先进后出（FILO）,队列的特性是先进先出（FIFO）,
在实现delete时，将一个栈中的数据依次拿出来压入到另一个为空的栈，另一个栈中数据的顺序恰好是先压入栈1的元素, 此时在栈2的上面。为了实现效率的提升，在delete时，判断栈2是否有数据，如果有的话，直接删除栈顶元素，在栈2为空时才将栈1的数据压入到栈2中，从而提高程序的运行效率

- `push` 操作时，一直将数据压入到 `栈2` 中
- `delete` 操作时，首先判断 `栈2` 是否为空
	- 不为空的情况直接删除 `栈2` 栈顶元素
	- 为空的话将 `栈1` 的数据压入到 `栈2` 中，再将 `栈2` 栈顶元素删除。

#### 两个队列实现一个栈
> 因为队列是先进先出，所以要拿到队列中最后压入的数据，只能每次将队列中数据pop到只剩一个，此时这个数据为最后压入队列的数据，在每次pop时，将数据压入到另一个队列中。每次执行delete操作时，循环往复。（感觉效率低）每次删除时间复杂度O(N)

### 31. Dir()方法

	- 用 dir()函数可以查看对像内所有属性及方法
