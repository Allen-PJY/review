# 网络通信

### 3. 线程、进程、协程

- **进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
- **线程**是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存
器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
- **协程**是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### 5. 谈谈你对 `同步` `异步` `阻塞` `非阻塞` 理解

- **同步**，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。

	> 按照这个定义，其实绝大多数函数都是同步调用（例如sin,isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的LRESULT值返回给调用者。

- **异步**，和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。

	> 实际处理这个调用的部件在完成后，通过`状态`、 `通知` 和 `回调` 来通知调用者。以 CAsycSocket 类为例（注意，CSocket 从CAsyncSocket 派生，但是起功能已经由异步转化为同步），当一个客户端通过调用Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。

- **阻塞**调用是指调用结果返回之前，当前线程会被挂起。
	
	> 函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket 中调用 Receive 函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket 接收数据的另外一个函数 recv 则是一个阻塞调用的例子。当 socket 工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。

- **非阻塞**，和阻塞的概念相对。指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

	> 对象的阻塞模式和阻塞函数调用。对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。


### 10. 什么是线程安全?

- 在多线程的环境下，能够保证多个线程同时执行时程序依旧运行正确

- 对于共享的数据可以由多个线程存取，但是同一时刻只能有一个线程进行存取

- 多线程环境下解决资源竞争问题的办法是**加锁**


### 12. POST和GET区别

- 1、数据的位置
    - GET请求，请求的数据会附加在URL之后，以 `?` 分割URL和传输数据，多个参数用 `&` 连接。
        - URL的编码格式采用的是ASCII编码，而不是unicode，即是说所有的非ASCII字符都要编码之后再传输。
    - POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。
    - 因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。

- 2、传输数据的大小
    - 在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。
    - 但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。
    - 因此，在使用GET请求时，传输数据会受到URL长度的限制。
    - 对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。
- 3、安全性
    - POST的安全性比GET的高。

        > 这里的安全是指真正的安全，而不同于安全方法中的安全，那种安全仅仅是不修改服务器的数据。
    
    - 比如，在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。
    - 除此之外，GET请求提交的数据还可能会造成`Cross-site request frogery`攻击。

### 13. 三次握手和四次挥手

- **三次握手**
建立连接的过程是利用客户端服务器模式，假设主机A为客户端，主机B为服务器端。
    - （1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。
    - （2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。
失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。
考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。
    - （3）采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况，因此采用三次握手刚刚好，两次可能出现失效，四次甚至更多次则没必要，反而复杂了

- **四次挥手**
    - 先由客户端向服务器端发送一个FIN，请求关闭数据传输。
    - 当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ
    - 然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。
    - 当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ

- 名词解释
    - SYN: Synchronize Sequence Numbers 同步序列编号
    - ACK: Acknowledgement Number 确认编号
    - FIN: Finish 结束标志

![三次握手&四次挥手图解](http://p4emt3ysm.bkt.clouddn.com/tcp.png)

### 14. 多线程有哪些模块
- 在Python中可使用的多线程模块主要有两个，`thread` 和 `threading` 模块。


### 19. 什么是URL
- URL，即统一资源定位符，也就是我们说的网址
- 统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址
- 互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。


### 24. 网络传输层

层|协议
-|-
应用层 | http ftp dns nfs
传输层 | tcp udp
网络层 | ip icmp igmp
链路层 | data link
物理层 | media

### 25. 设置ip和掩码

```bash
ifconfig eth0 192.168.6.8 netmask 255.255.255.0
```

### 26. 设置网关

```bash
route add default gw 192.168.6.1
```

### 27. `2MSL`

- `2MSL`即两倍的`MSL`，TCP的`TIME_WAIT`状态也称为`2MSL`等待状态，
- 当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了`TIME_WAIT`状态
- 必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到
- 那么对方在超时后将重发第三次握手的`FIN`包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包
- 在`TIME_WAIT`状态时两端的端口不能使用，要等到`2MSL`时间结束才可继续使用。
- 当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。
- 在实际应用中可以通过设置`SO_REUSEADDR`选项达到不必等待2MSL时间结束再使用此端口。

### 28. `TTL`，`MSL`，`RTT`

- `TTL`：**生存时间** (`timetolive`)
    - 这个生存时间是由源主机设置初始值但不是生存的具体时间，而是存储了一个ip数据报可以经过的最大路由数
    - 每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃
    - 同时发送`ICMP`报文通知源主机。`RFC793`中规定`MSL`为2分钟，实际应用中常用的是30秒，1分钟和2分钟等
    - `TTL`与`MSL`是有关系的但不是简单的相等的关系，`MSL`要大于等于`TTL`

- `MSL`：**报文最大生存时间** (`Maximum Segment Lifetime`)
    - 它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

- `RTT`：**客户到服务器往返所花时间** (`round-trip time`)
    - TCP含有动态估算RTT的算法。
    - TCP还持续估算一个给定连接的RTT，这是因为RTT受网络传输拥塞程序的变化而变化。

### 29. 创建一个简单tcp服务器需要的流程

No.|步骤|方法
-|-|-
1 | 创建套接字 | tcp_server_socket = socket(AF_INET, SOCK_STREAM)
2 | 设置服务器地址 | server_addr = ('127.0.0.1', 6666)
3 | 绑定地址 | tcp_server_socket.bind(server_addr)
4 | 监听 | tcp_server_socket.listen(128)
5 | 生成客户端套接字 | client_socket, client_addr = tcp_server_socket.accept()
6 | 接受内容 | recv_msg = client_socket.recv(1024).decode('gbk')
7 | 发送内容 | client_socket.send(send_msg.encode('gbk'))
8 | 关闭套接字 | client_socket.close() tcp_server_socket.close()


### 31. 网络协议概述

- 应用层

Abbr.   | Protocol                              | Description
-|-|-
 FTP    | File Transfer Protocol                | 文件传输协议
 HTTP   | Hyper Text Transfer Protocol          | 超文本传输协议
 SMTP   | Simple Mail Transfer Protocol         | 简单邮件传输协议
 POP3   | Post Office Protocol                  | 邮局协议
 DNS    | Domain Name System                    | 域名系统

- 传输层

Abbr.   | Protocol                              | Description
-|-|-
 TCP    | Transmission Control Potocol          | 传输控制协议
 UDP    | User Datagram Potocol                 | 用户数据报协议

- 网络层

Abbr.   | Protocol                              | Description
-|-|-
 IP     | Internet Protocol                     | 网络协议
 ARP    | Adderss Resolution Protocol           | 地址解析协议
 ICMP   | Internet Control Message Protocol     | 控制报文协议
 HDLC   | High Data Link Control                | 高级数据链路控制

- 数据链路层

Abbr.   | Protocol                              | Description
-|-|-
 SLIP   | Serial Line Internet Protocol         | 串行线路网际协议
 PPP    |                                       | 点对点协议

- 物理层
    - 放大/再生若的信号，在两个电缆段之间复制每一个比特

### 32. HTTP/HTTPS的区别，应用场合
- HTTP和HTTPS的区别
    - 端口不一样,前者是80,后者是443
    - http是超文本传输协议，信息是明文传输，连接很简单，是无状态的
    - https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全
    - https协议需要到ca申请证书，需要交费

- 应用场合
    - http:适合于对传输速度要求高，安全性要求不是很高，且需要快速开发的应用。如web应用，小的手机游戏等.
    - https:用于任何场景！

### 33. HTTPS优点和缺点
- 优点：
    - （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
    - （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性
    - （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本
    - （4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”

- 缺点：
    - （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电
    - （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响
    - （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用
    - （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗
    - （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行


### 34. HTTPS通信步骤

![https](http://p4emt3ysm.bkt.clouddn.com/https%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png)

- （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
- （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
- （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
- （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
- （5）Web服务器利用自己的私钥解密出会话密钥。
- （6）Web服务器利用会话密钥加密与客户端之间的通信。


### 35. 国内外有哪些机构可以申请HTTPS证书

- 国内：
    - 沃通(WoSign) 中国人民银行联合12家银行建立的金融CFCA
    - 中国电信认证中心（CTCA） 海关认证中心（SCCA）
    - 国家外贸部EDI中心建立的国富安CA安全认证中心
    - SHECA（上海CA）为首的UCA协卡认证体系

- 国外：
    - StartSSL
    - GlobalSign
    - GoDaddy
    - Symantec

### 36. get和post请求有什么区别，分别应该在什么场合下

- **get**: 从指定的服务器中获取数据
    - GET请求能够被缓存
    - GET请求会保存在浏览器的浏览记录中
    - 以GET请求的URL能够保存为浏览器书签
    - GET请求有长度限制
    - GET请求主要用以获取数据

- **post**: 向指定的服务器中发送数据
    - POST请求不能被缓存下来
    - POST请求不会保存在浏览器浏览记录中
    - 以POST请求的URL无法保存为浏览器书签
    - POST请求没有长度限制
    - POST请求会把请求的数据放置在HTTP请求包的包体中
    - POST的安全性比GET的高.可能修改变服务器上的资源的请求.

- **应用场合**：
    - post：
        - 要传送的数据不是采用7位的ASCII编码
        - 请求的结果有持续性的副作用（数据库内添加新的数据行）
        - 如果使用GET方法，表单上收集的数据可能让URL过长
    - get：
        - 请求是为了查找资源，HTML表单数据仅用来帮助搜索
        - 请求结果无持续性的副作用
        - 收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符

### 37. HTTP请求会有哪些信息发送到后台服务器
- 请求行
    - POST /demo/login HTTP/1.1
- 请求头
- 请求体
    - username=xxxx&password=1234
