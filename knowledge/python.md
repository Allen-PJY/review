# Linux及Python语法

### 什么是函数

- 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

- 函数能提高应用的模块性，和代码的重复利用率。

- Python提供了许多内建函数，但也可以自己创建函数，这被叫做用户自定义函数

### Python的引用类型有哪些

- 对象本身可以修改，比如列表，字典等

### `self` 和 `cls` 区别

- 一般用到 `staticmethod`, `classmethod` 或者后期绑定就用 `cls`
- 否则就用 `self` , 属于 `*args` 的范畴的

### `map`函数和`reduce`函数

- 参数：
    - `map`/`reduce` 都包含两个参数，参一是函数对象，参二是可迭代对象（列表或元组）

- 参一函数的参数：
    - `map` 参一位置的函数，可以接受1个或者多个参数
    - `reduce` 参一位置的函数，只能接受两个参数

- 对可迭代对象的作用方式：
    - `map` 是将传入的函数依次作用于序列的每个元素，每个元素都是独自被函数“作用”一次
    - `reduce` 是将传人的函数作用在序列的第一个元素得到结果后，再把这个结果继续与下一个元素作用（累积计算）

- 返回值的类型
    - `map` 返回值是一个迭代器
    - `reduce` 返回值和参一函数的返回值类型相同

### 迭代器和生成器区别

- **迭代器** `Iterator` 是一个更抽象的概念
    - 任何对如果它类有`next`方法和`iter`方法返回自己本身。
    - 对于`string`、`list`、`dict`、`tuple`等这类容器对象，使用for循环遍历是很方便的。
    - 在后台for语句对容器象调用`iter()`函数
    - `iter()`会返回一个定义`next()`方法的迭代器对象，它在容器中逐个访问容器内元素
    - 在没有后续元素时，`next()`会抛出一个`StopIteration`异常

- **生成器** `Generator` 是创建迭代器的简单而强大工具。
    - 它们写起来就像是正规的函数，只在需要返回据时候使用 `yield` 语句。
    - 每次 `next()` 被调用，生成器会返回它脱离的位置，记忆语句最后一次执行和所有数据。

- 区别：
    - 生成器能做到迭代器的所有事 ,而且因为自动创建了`__iter__()`和 `__next__()`方法
    - 生成器显得特别简洁 ,而且生成器也是高效的
    - 使用生成器表达式取代列解析可以同时节省内存。
    - 除了创建和保持程序状态的自动方法,当生成器终结时,还会自动抛出`StopIteration`异常。



### 装饰器

> 装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

- 装饰器`decorator`里引入通用功能处理
    - 引入日志
    - 函数执行时间统计
    - 执行函数前预备处理
    - 执行函数后清理功能
    - 权限校验等场景
    - 缓存

```python
from time import ctime, sleep


def timefun(func):
    def wrappedfunc():
        print("%s called at %s"%(func.__name__, ctime()))
        return func()
    return wrappedfunc

@timefun
def foo():
    print("I am foo")


foo()
sleep(2)
foo()
```


### **GIL** 
- 全称是 Global Interpreter Lock(全局解释器锁)，来源是 python 设计之初的考虑，为了数据安全所做的决定。
- 每个 CPU 在同一时间只能执行一个线程
- 在单核 CPU 下的多线程其实都只是并发，不是并行，并行和并发从宏观上来讲都是同时处理多路请求的概念。
- 并行是指两个或者多个事件在同一时刻发生
- 并发是指两个或多个事件在同一时间间隔内发生
- 在 Python 多线程下，每个线程的执行方式：
    - 1、获取 GIL
    - 2、执行代码直到 sleep 或者是 python 虚拟机将其挂起。
    - 3、释放 GIL

    > 可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是“通行证”，并且在一个 python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行在 Python2.x 里，GIL 的释放逻辑是当前线程遇见 IO 操作或者ticks 计数达到 100（ticks 可以看作是 Python 自身的一个计数器，专门做用于 GIL，每次释放后归零，这个计数可以通过sys.setcheckinterval 来调整），进行释放。而每次释放 GIL 锁，线程进行锁竞争、切换线程，会消耗资源。并且由于 GIL 锁存在，python 里一个进程永远只能同时执行一个线程(拿到 GIL 的线程才能执行)。

    > IO 密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有 IO 操作会进行 IO 等待，造成不必要的时间浪费，而开启多线程能在线程 A 等待时，自动切换到线程 B，可以不浪费 CPU的资源，从而能提升程序执行效率)，所以多线程对 IO 密集型代码比较友好。

### **反射**
> 利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动。

- 1.根据字符串的形式导入模块

```python
# 单层导入
import re
__import__('re')

# 多层导入
from a.b import c
__import__('a.b.c', fromlist=True)  # 如果不加上fromlist=True,只会导入list目录
```

- 2.根据字符串的形式去对象（某个模块）中操作其成员

BIF | Description
-|-
getattr | 获取成员
hasattr | 检查成员
setattr | 设置成员
delattr | 删除成员

```python
class Foo(object):
    """验证成员函数"""
    def __init__(self):
        self.name = 'xiaoming'

    def func(self):
        return 'ok'


foo = Foo()

# 获取成员
ret = getattr(foo, 'func')
r = ret()
print(r)  # ok

# 检查成员
ret = hasattr(foo,'func')
print(ret)  # True

# 设置成员
print(foo.name)  # xiaoming
ret = setattr(foo,'name','laowang')
print(foo.name)  # laowang

# 删除成员
print(foo.name) # laowang
delattr(foo,'name')
print(foo.name)  # AttributeError: 'Foo' object has no attribute 'name'
```


### Python2和Python3区别

#### *1. 性能*
- Py3.0 运行 `pystone benchmark` 的速度比 Py2.5 慢 30%。Guido 认为 Py3.0 有极大的优化空间，在字符串和整形操作上可以取得很好的优化结果。
- Py3.1 性能比 Py2.5 慢 15%，还有很大的提升空间。

#### *2. 编码*
- py3 源码文件默认使用 `utf-8` 编码，这就使得以下代码是合法的：
```python
>>> 中国 = 'china'
>>> print(中国)
china
```

#### *3. 语法*
- 去除了 `<>`，全部改用 `!=`
- 去除 `` ` ` `` ，全部改用 `repr()`
- 关键词加入 `as` 和 `with`，还有 `True`, `False`, `None`
- 整型除法返回浮点数，要得到整型结果，请使用 `//`
- 加入 `nonlocal` 语句。使用 `noclocal x` 可以直接指派外围（非全局）变量
- 去除 `print` 语句，加入 `print()` 函数实现相同的功能。同样的还有 `exec` 语句，已经改为 `exec()`函数
- 改变了顺序操作符的行为，例如 `x<y`，当 `x` 和 `y` 类型不匹配时抛出 `TypeError` 而不是返回随即的 `bool` 值
- 输入函数改变了，删除了 `raw_input`，用 `input` 代替：
    - py2 ``guess = int(raw_input('Enter an integer: '))``
    - py3 ``guess = int(input('Enter an integer: '))``
- 去除元组参数解包。不能 `def(a, (b, c)):pass` 这样定义函数了
- 新式的`8进制`字变量，相应地修改了 `oct()` 函数。
- 增加了`2进制`字面量和 `bin()` 函数
- 扩展的可迭代解包。在 py3里，`a, b, *rest = seq`和 `*rest, a = seq` 都是合法的，
    - `rest` 是 列表类型
    - `seq` 是可迭代的。
- 新的 `super()`，可以不给 `super()`传参数，
- 新的 `metaclass` 语法：
```python
class Foo(*bases, **kwds):
    pass
```
- 支持 `class decorator`。用法与函数 `decorator` 一样：

#### *4. 字符串和字节串*
- 现在字符串只有 `str` 一种类型，但它跟 2.x 版本的 `unicode` 几乎一样。
- 关于`字节串`，请参阅**数据类型**的第2条目

#### *5. 数据类型*
- py3 去除了 `long` 类型，现在只有一种整型`int`，但它的行为就像 py2的 `long`
- 新增了 `bytes` 类型，对应于py2版本的八位串，定义一个 bytes 字面量的方法如下：
    - str 对象和 bytes 对象可以使用`.encode()` *(str -> bytes)* 以及 `.decode()` *(bytes -> str)* 方法相互转化。
- *`dict`* 的`.keys()`、`.items()` 和`.values()`方法返回**迭代器**，而之前的 `iterkeys()`等函数都被废弃。
    - 同时去掉的还有`dict.has_key()`，用 `in` 替代它吧

#### *6. 面向对象*
- 引入抽象基类 `ABCs` *`(Abstraact Base Classes)`*。
- 容器类和迭代器类被 `ABCs` 化，所以 `cellections` 模块里的类型比 Py2.5 多了很多。

        >>> import collections
        >>> print('\n'.join(dir(collections)))
    - `Callable` `Container` `Hashable` `ItemsView` `Iterable` `Iterator` `KeysView` `Mapping`
    - 另外，数值类型也被 `ABCs` 化。关于这两点，请参阅 `PEP 3119` 和 `PEP 3141`。

- 迭代器的 `next()` 方法改名为 `__next__()` ，并增加内置函数 `next()`，用以调用迭代器的 `__next__()` 方法
- 增加了`@abstractmethod` 和 `@abstractproperty` 两个 `decorator`，编写抽象方法（属性）更加方便。

#### *7. 异常*
- 所有异常都从 `BaseException` 继承，并删除了 `StardardError`
- 去除了异常类的序列行为和 `.message` 属性
- 用 `raise Exception(args)` 代替 `raise Exception, args` 语法
- 捕获异常的语法改变，引入了 `as` 关键字来标识异常实例
- 异常链，因为`__context__`在 3.0a1 版本中没有实现

#### *8. 模块变动*
- 移除了 `cPickle` 模块，可以使用 `pickle` 模块代替。最终我们将会有一个透明高效的模块。
- 移除了 `imageop` 模块
- 移除了 `audiodev`, `Bastion`, `bsddb185`, `exceptions`, `linuxaudiodev`, `md5`, `MimeWriter`, `mimify`, `popen2`,
`rexec`, `sets`, `sha`, `stringold`, `strop`, `sunaudiodev`, `timing` 和 `xmllib` 模块
- 移除了 `bsddb` 模块(单独发布，可以从 http://www.jcea.es/programacion/pybsddb.htm 获取)
- 移除了 `new` 模块
- `os.tmpnam()` 和 `os.tmpfile()` 函数被移动到 `tmpfile` 模块下
- `tokenize` 模块现在使用 `bytes` 工作。主要的入口点不再是 `generate_tokens`，而是 `tokenize.tokenize()`

#### *9. 其它*
- `xrange()` 改名为 `range()`，要想使用 `range()`获得一个 *`list`*，必须显式调用：

        >>> list(range(10)) 
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

- `bytes` 对象不能 `hash`，也不支持 `b.lower()`、`b.strip()` 和 `b.split()` 方法，但对于后两者可以使用 `b.strip(b' \n\t\r\f')` 和 `b.split(b' ')` 来达到相同目的
- `zip()`、`map()`和 `filter()`都返回迭代器。
    - 去除了`apply()`、`callable()`、`coerce()`、`execfile()`、`reduce()`、 `reload ()`
    - 现在可以使用 `hasattr()`来替换 `callable()`
        - `hasattr()`的语法如：`hasattr(string, '__name__')`
- `string.letters` 和相关的`.lowercase` 和`.uppercase` 被去除，请改用 `string.ascii_letters`等
- `__getslice__`系列成员被废弃。`a[i:j]`根据上下文转换为 `a.__getitem__(slice(i, j))` 或 `__setitem__` 和 `__delitem__` 调用
- `file` 类被废弃


### 什么是PEP8

#### *1. 变量*

- **常量**：大写加下划线 `CONSTANT_VALUE`
- **私有变量**：小写和一个前导下划线 `_private_value`

    > Python 中不存在私有变量一说，若是遇到需要保护的变量，使用小写和一个前导下划线。但这只是程序员之间的一个约定，用于警告说明这是一个私有变量，外部类不要去访问它。但实际上，外部类还是可以访问到这个变量。

- **内置变量**：小写，两个前导下划线和两个后置下划线 `__class__`

    > 两个前导下划线会导致变量在解释期间被更名。这是为了避免内置变量和其他变量产生冲突。用户定义的变量要严格避免这种风格。以免导致混乱。

#### *2. 函数和方法*
- 总体而言应该使用，小写和下划线。

    > 有些比较老的库使用的是混合大小写(小驼峰)。但现在，小写和下划线已成为规范。

- **私有方法**：小写和一个前导下划线

        def _secrete(self):
            print "don't test me."

    > 这里和私有变量一样，并不是真正的私有访问权限。同时也应该注意一般函数不要使用两个前导下划线(当遇到两个前导下划线时，Python 的名称改编特性将发挥作用)。

- **特殊方法**：小写和两个前导下划线，两个后置下划线

        def __add__(self, other):
            return int.__add__(other)

    - 这种风格只应用于特殊函数，比如操作符重载等。

- **函数参数**：小写和下划线，缺省值等号两边无空格

#### *3. 类*
- 类总是使用`大驼峰命名`，即所有单词首字母大写其余字母小写。

- 类名应该简明，精确，可以从中理解类所完成的工作。

- 常见的一个方法是使用表示其类型或者特性的后缀
    - `SQLEngine`，`MimeTypes` 

- 对于基类而言可以使用一个 `Base` 或者 `Abstract` 前缀
    - `BaseCookie`，`AbstractGroup`

#### *4. 模块和包*

- 除特殊模块 `__init__` 之外，模块名称都使用**不带下划线**的**小写字母**。

- 若是它们实现一个协议，那么通常使用 `lib` 为后缀
    - `import os`
    - `import sys`
    - `import smtplib`

#### *5. 关于参数*

- 不要用断言来实现静态类型检测

    > 断言可以用于检查参数，但不应仅仅是进行静态类型检测。Python 是动态类型语言，静态类型检测违背了其设计思想。断言应该用于避免函数被毫无意义的调用。

- 不要滥用 `*args` 和 `**kwargs`

    > `*args` 和 `**kwargs` 参数可能会破坏函数的健壮性。它们使签名变得模糊，而且代码常常开始在不应该的地方构建小的参数解析器。

#### *6. 其它*

- 使用 `has` 或 `is` 前缀命名布尔元素
    - is_connect = True
    - has_member = False

- 用复数形式命名序列
    - members = ['user_1', 'user_2']

- 用显式名称命名字典
    - person_address = {'user_1': '10 road WD', 'user_2': '20 street huafu'}

- 避免通用名称
    - 避免 `list`、`dict`、`sequence`、`element` 等

- 避免系统名称
    - 避免 `os`、`sys` 等

#### *7. 一些数字*
- 一行列数
    - `PEP 8` 规定为 **79** 列
    - 根据自己的情况，比如不要超过满屏时编辑器的显示列数。

- 一个函数
    - 不要超过 **30** 行代码, 即可显示在一个屏幕。

- 一个类
    - 不要超过 **200** 行代码
    - 不要有超过 **10** 个方法

- 一个模块
    - 不要超过 **500** 行。

#### *8. 验证脚本*
- 可以安装一个 `pep8` 脚本用于验证你的代码风格是否符合 `PEP8`



### 十个常用的linux命令

- `cd`, `ls`, `clear`, `mkdir`, `mv`, `pwd`, `rm`, `grep`, `more`, `help`

### `find` 和 `grep`

- `grep` 命令是一种强大的文本搜索工具

- `grep` 搜索内容串可以是正则表达式，允许对文本文件进行模式查找。

- 如果找到匹配模式，`grep` 打印包含模式的所有行。

- find 通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。

### 什么是面向对象编程

- 面向对象编程是一种**解决软件复用**的设计和编程方法。

- 目的是提高软件开发效率。

- 把软件系统中相似的*操作逻辑*和*操作应用数据、状态*以`类`的型式描述出来

- 以对象实例的形式在软件系统中复用

### 面向对象有哪些技术

- **类(Class)**
    - 用来描述具有相同的属性和方法的对象的集合。
    - 它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。

- **类变量**
    - 类变量在整个实例化的对象中是公用的。
    - 类变量定义在类中且在函数体之外。
    - 类变量通常不作为实例变量使用。

- **数据成员**
    - 类变量或者实例变量用于处理类及其实例对象的相关的数据。

- **方法重写**
    - 如果从父类继承的方法不能满足子类的需求，可以对其进行改写
    - 这个过程叫方法的覆盖（override），也称为方法的重写。

- **实例变量**
    - 定义在方法中的变量，只作用于当前实例的类。

- **继承**
    - 即一个派生类`derived class` 继承基类 `base class` 的属性和方法。
    - 继承也允许把一个派生类的对象作为一个基类对象对待。

        > 一个 Dog 类型的对象派生自 Animal 类，这是模拟"是一个（is-a）"关系（例图，Dog是一个 Animal）。

- **实例化**：创建一个类的实例，类的具体对象。

- **方法**：类中定义的函数。

- **对象**：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。


### 静态方法和类方法

- **静态方法**：
    - 用 `@staticmethod` 装饰
    - 静态方法不需要多定义参数。

- **类方法**：类方法是类对象所拥有的方法
    - 用 `@classmethod` 装饰
    - 第一个参数必须是**类对象**，一般以 `cls` 作为第一个参数（也可以用其它名称）
    - 能够通过实例对象和类对象去访问。

### 类属性和实例属性

- **类属性**：
    - 定义在类里面但在函数外面的变量，是静态的。 
    - 类对象所拥有的属性
    - 它被所有 `类对象` 的 `实例对象` 所共有，在内存中只存在一个副本。
    - 对于公有的类属性，在类外可以通过 `类对象` 和 `实例对象` 访问。

- **实例属性**：
    - 定义在 `__init__()` 方法里的变量就是实例属性
    - 只有被创建时才会被创建。
    - 当类属性与实例属性同名时，实例对象访问这个属性时其实访问的是实例属性


### 利用shell执行定时任务
```bash
sudo crontab -e
* */1 * * * /usr/local/etc/rc.d/lighttpd restart  # 每一小时重启 apache
```

```bash
*　*　*　*　*　command 
# 分　时　日　月　周　命令
# 第1列表示分钟1～59 每分钟用*或者 */1表示
# 第2列表示小时1～23（0表示0点）
# 第3列表示日期1～31
# 第4列表示月份1～12
# 第5列标识号星期0～6（0表示星期天）
# 第6列要运行的命令
```


### 线上服务可能因为种种原因导致挂掉怎么办

- Linux 下的后台进程管理利器 `supervisor`
- 每次文件修改后在 linux 执行：`service supervisord restart`

### python的多进程与多线程的运行机制是什么？有什么区别？分别在什么情况下用

- **运行机制**：
    - **进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位
    - **线程**是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源
    
        > 如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。程序计数器,一组寄存器和栈,但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

- **区别**：
    - 多进程稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程
    - 创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源
    - 操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态
    - 多线程效率较高一些，但是致命的缺点是任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。

- **使用情况**：
    - IO 密集型，多线程。
    - CPU 密集型，多进程
        - 特别是所使用的机器是多核或多CPU的。

### 如何提高Python的运行效率，请说出不少于2种提高运行效率的方法

- 使用生成器

- 关键代码使用外部功能包：`Cython`、`Pylnlne`、`PyPy`、`Pyrex`

- 针对循环的优化——尽量避免在循环中访问变量的属性；

### 介绍下 **`消费者`** 和 **`生产者`** 模型

> 生产者-消费者模型是多线程同步的经典案例。此模型中生产者向缓冲区 `push` 数据，消费者从缓冲区中 `pull` 数据。
缓冲区用 `Queue` 实现的，这个模块是线程安全的使开发者不用再为队列增加额外的互斥锁.

- 信号处理的实现：
    - 1）主线程接到一个 `SIGTERM` 的信号后先通知 `Consumer` 停止向缓冲区 `push` 数据并退出
    - 2）`Produer` 将缓冲区中的数据消费完全后再退出
    - 3）主线程退出

- 优点：

    - **解耦**
        - 假设生产者和消费者分别是两个类。
        - 让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。
        - 如果消费者的代码发生变化，可能会影响到生产者。
        - 如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。

    - **支持并发**
        - 由于生产者与消费者是两个独立的并发体，他们之间是用缓冲区作为桥梁连接，
        - 生产者只需要往缓冲区里丢数据，就可以继续生产下一个数据，
        - 消费者只需要从缓冲区了拿数据即可，这样就不会因为彼此的处理速度而发生阻塞。

    - **支持忙闲不均**
        - 如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。
        - 当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。
        - 等生产者的制造速度慢下来，消费者再慢慢处理掉。


### `MD5`

- `MD5` 功能：
    - 输入任意长度的信息，经过处理，输出为 `128` 位的信息（数字指纹）
    - 不同的输入得到的不同的结果（唯一性）；
    - 输出结果不可反推（不可逆）；

- `MD5` 用途：
    - 防止被篡改
    - 防止直接看到明文
    - 防止抵赖（数字签名）

- `MD5` 算法过程：
    - MD5以`512位分组`来处理输入的信息
    - 每一分组又被划分为`16个32位子分组`
    - 经过了一系列的处理后，算法的输出由`四个32位分组`组成
    - 将这`四个32位分组`级联后将生成一个`128位散列值`

### 哈希表

- 哈希表就是一种以 `键-值(key-indexed)` 存储数据的结构，我们只要输入待查找的键 `key`，即可查找到其对应的值 `value`。

> 哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：
将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。
这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

- 哈希查找两步走:

    - 1) 使用哈希函数将被查找的键转换为数组的索引
        - 在理想的情况下，不同的键会被转换为不同的索引值
        - 但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况
        - 所以哈希查找的第二个步骤就是处理冲突

    - 2) 处理哈希碰撞冲突。
        - 哈希表是一个在时间和空间上做出权衡的经典例子
        - 如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为 O(1)
        - 如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存
        - 哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡
        - 只需要调整哈希函数算法即可在时间和空间上做出取舍

### python的魔法方法

> 魔法方法就是可以给你的类增加魔力的特殊方法，
如果你的对象实现（重载）了这些方法中的某一个，
那么这个方法就会在特殊的情况下被Python所调用，你可以定义自己想要的行为，而这一切都是自动发生的。
它们经常是两个下划线包围来命名的（比如 `__init__` ，`__lt__`），Python的魔法方法是非常强大的，所以了解其使用方法也变得尤为重要！

- `__init__ ` 构造器，当一个实例被创建的时候初始化的方法。但是它并不是实例化调用的第一个方法。

- `__new__` 才是实例化对象调用的第一个方法，它只取下 `cls` 参数，并把其他参数传给 `__init__` 。
    - `__new__` 很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。

- `__call__` 允许一个类的实例像函数一样被调用

- `__getitem__` 定义获取容器中指定元素的行为，相当于 self[key]

- `__getattr__` 定义当用户试图访问一个不存在属性的时候的行为

- `__setattr__` 定义当一个属性被设置的时候的行为

- `__getattribute__` 定义当一个属性被访问的时候的行为


### 字符、字符集、字符编码

- 字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。

- 字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同

- 字符编码就是以二进制的数字来对应字符集的字符。

- 常见字符集（编码字符集）有：`ASCII` 字符集、`ISO 8859` 字符集、`GB2312` 字符集、`BIG5` 字符集、`GB18030` 字符集、`Unicode` 字符集等。

    - `Unicode`：也叫统一字符集，它包含了几乎世界上所有的已经发现且需要使用的字符（如中文、日文、英文、德文等）。
    - `ASCII`：ASCII既是编码字符集，又是字符编码。
        - 早期的计算机系统只能处理英文，所以ASCII也就成为了计算机的缺省字符集，包含了英文所需要的所有字符。
    - `GB2312`：中文字符集，包含 `ASCII` 字符集。`ASCII` 部分用单字节表示，剩余部分用双字节表示。
    - `GBK`：`GB2312` 的扩展，但完整包含了 `GB2312` 的所有内容。
    - `GB18030`：GBK 字符集的超集，常叫*大汉字字符集*，也叫 `CJK`（Chinese，Japanese，Korea）字符集，包含了中、日、韩三国语言

- *注意：*
    - `Unicode` 字符集有多种编码方式，如 `UTF-8`、`UTF-16` 等
    - `ASCII` 只有一种
    - 大多数 `MBCS`（包括 `GB2312`）也只有一种。

### `with`语句

- `with`语句适用于对资源进行访问的场合

- 确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源

- 比如文件使用后自动关闭、线程中锁的自动获取和释放等。

### Dir()方法

    - 用 dir()函数可以查看对像内所有属性及方法

### 线程、进程、协程

- **进程**是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。
- **线程**是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存
器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
- **协程**是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

### 谈谈你对 `同步` `异步` `阻塞` `非阻塞` 理解

- **同步**，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。

    > 按照这个定义，其实绝大多数函数都是同步调用（例如sin,isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。最常见的例子就是SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的LRESULT值返回给调用者。

- **异步**，和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。

    > 实际处理这个调用的部件在完成后，通过`状态`、 `通知` 和 `回调` 来通知调用者。以 CAsycSocket 类为例（注意，CSocket 从CAsyncSocket 派生，但是起功能已经由异步转化为同步），当一个客户端通过调用Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。这里提到执行部件和调用者通过三种途径返回结果：状态、通知和回调。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用通知的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。

- **阻塞**调用是指调用结果返回之前，当前线程会被挂起。
    
    > 函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket 中调用 Receive 函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。socket 接收数据的另外一个函数 recv 则是一个阻塞调用的例子。当 socket 工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。

- **非阻塞**，和阻塞的概念相对。指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

    > 对象的阻塞模式和阻塞函数调用。对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。


### 什么是线程安全?

- 在多线程的环境下，能够保证多个线程同时执行时程序依旧运行正确

- 对于共享的数据可以由多个线程存取，但是同一时刻只能有一个线程进行存取

- 多线程环境下解决资源竞争问题的办法是**加锁**
